<snippet>
	<content><![CDATA[
template <typename T>
struct LAZY {
	vector<T>v, t, L;
	size_t size = 0;

	LAZY(const vector<T>&vv) {
		v = vv;
		size = int(vv.size());
		t.assign(size << 2 , 0);
		L.assign(size << 2 , -1); // change to 0 in need
		if (!vv.empty())
			build(1, 1, size);
	}

	void push(T node, T st, T en) {
		if (L[node] == -1) {
			return;
		} else {
			t[node] = (en - st + 1) * L[node]; // change in need
			T mid = (st + en) >> 1;
			if (st != en) {
				L[node << 1] =  L[node << 1 | 1] = L[node] ; // propagate
			}
			L[node] = -1;
		}
	}

	T mrge(T a, T b) {
		return (a + b);//change in need
	}

	void build(T N , T s, T e) {
		if (s == e) {
			t[N] = v[s];
			return;
		}
		int mid = (s + e) >> 1;
		build(N << 1, s, mid);
		build(N << 1 | 1, mid + 1, e);
		t[N] = mrge(t[N << 1], t[N << 1 | 1]);
	}

	void update(T l, T r, T v) {
		update(1, 1, size, l, r, v);
	}

	void update(T N, T s, T e, T l, T r, T x) {
		push(N, s, e);
		if (s > r || e < l) {
			return;
		}
		if (s >= l && e <= r) {
			L[N] = x; // change in need
			push(N, s, e);
			return;
		} else {
			int m = (s + e) >> 1;
			update(N << 1, s, m, l, r, x);
			update(N << 1 | 1, m + 1, e, l, r, x);
			t[N] = mrge(t[N << 1] , t[N << 1 | 1]);
		}
	}

	T query(T l, T r) {
		return query(1, 1, size, l, r);
	}

	T query(T N, T s, T e, T l, T r) {
		push(N, s, e);
		if (s > r || e < l)return 0;//change in need
		if (s >= l && e <= r)return t[N];
		else {
			int m = (s + e) >> 1;
			T q1 = query(N << 1, s, m, l, r);
			T q2 = query(N << 1 | 1, m + 1, e, l, r);
			return mrge(q1, q2);
		}
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>LAZY</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
