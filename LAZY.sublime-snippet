<snippet>
	<content><![CDATA[
template <typename T>
struct LazySegmentTree {
    vector<T> data, tree, lazy;
    size_t n;

    LazySegmentTree(const vector<T>& values) {
        data = values;
        n = values.size();
        tree.assign(n << 2, 0);
        lazy.assign(n << 2, -1);
        if (!values.empty())
            build(1, 0, n - 1);
    }

    void push(int node, int start, int end) {
        if (lazy[node] != -1) {
            tree[node] = (end - start + 1) * lazy[node];
            if (start != end) {
                lazy[node << 1] = lazy[node];
                lazy[node << 1 | 1] = lazy[node];
            }
            lazy[node] = -1;
        }
    }

    T merge(T left, T right) {
        return left + right;
    }

    void build(int node, int start, int end) {
        if (start == end) {
            tree[node] = data[start];
            return;
        }
        int mid = (start + end) >> 1;
        build(node << 1, start, mid);
        build(node << 1 | 1, mid + 1, end);
        tree[node] = merge(tree[node << 1], tree[node << 1 | 1]);
    }

    void range_update(int left, int right, T value) {
        range_update(1, 0, n - 1, left, right, value);
    }

    void range_update(int node, int start, int end, int left, int right, T value) {
        push(node, start, end);
        if (start > right || end < left)
            return;
        if (start >= left && end <= right) {
            lazy[node] = value;
            push(node, start, end);
            return;
        }
        int mid = (start + end) >> 1;
        range_update(node << 1, start, mid, left, right, value);
        range_update(node << 1 | 1, mid + 1, end, left, right, value);
        tree[node] = merge(tree[node << 1], tree[node << 1 | 1]);
    }

    T range_query(int left, int right) {
        return range_query(1, 0, n - 1, left, right);
    }

    T range_query(int node, int start, int end, int left, int right) {
        push(node, start, end);
        if (start > right || end < left)
            return 0;
        if (start >= left && end <= right)
            return tree[node];
        int mid = (start + end) >> 1;
        T q1 = range_query(node << 1, start, mid, left, right);
        T q2 = range_query(node << 1 | 1, mid + 1, end, left, right);
        return merge(q1, q2);
    }
};

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>LAZY</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
